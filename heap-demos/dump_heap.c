#include  <stdlib.h>
#include  <string.h>
#include  <stdio.h>
#include  <sys/types.h>

/*
                print(c_error + "Debug glibc was not found, " \
                    "guessing main_arena address via offset from libc." + c_none)

                #find heap by offset from end of libc in /proc
                libc_end,heap_begin = read_proc_maps(inferior.pid)

                if SIZE_SZ == 4:
                    #__malloc_initialize_hook + 0x20
                    #offset seems to be +0x380 on debug glibc, +0x3a0 otherwise
                    arena_address = libc_end + 0x3a0
                elif SIZE_SZ == 8:
                    #offset seems to be +0xe80 on debug glibc, +0xea0 otherwise
                    arena_address = libc_end + 0xea0


                x/50xg libc_end+0xe00
*/


/*
 * main heap:
 *
 *      ptr[1]
 *      ptr[2]
 *      ptr[3]
 *      top chunk
 *
 *
 * */


#ifndef SIZE_T
#define SIZE_T size_t
#endif

#define x86_64


#ifdef x86_64
#define MAX_FASTBIN_SIZE    128
#define MAX_NORMALBIN_SIZE  1024  
#define MAX_LARGEBIN_SIZE   1024+64*32+512*16+4096*8+32768*4+262144*2
#else
#define MAX_FASTBIN_SIZE    64
#define MAX_NORMALBIN_SIZE  512  
#define MAX_LARGEBIN_SIZE   512+64*32+512*16+4096*8+32768*4+262144*2
#endif

typedef struct _malloc_chunk{
    SIZE_T prev_size;                       /* Size of previous chunk (if free).  */  
    SIZE_T size;                            /* Size in bytes, including overhead. */
    struct _malloc_chunk* fd;               /* double links -- used only if free. pointer to next chunk */
    struct _malloc_chunk* bk;               /* double links -- used only if free. pointer to previous chunk */
    /* Only used for large blocks: pointer to next larger size.  */
    struct _malloc_chunk* fd_nextsize;      /* double links -- used only if free. pointer to next large chunk*/
    struct _malloc_chunk* bk_nextsize;      /* double links -- used only if free. pointer to previous large chunk*/
}mchunk,*mchunk_ptr;


extern void* main_arena;

#define CHUNKSIZE           MAX_FASTBIN_SIZE/2


void* malloc_wrapper(int size);
void free_wrapper(void* ptr);

void malloc_all();
void free_all();




int i;
char *ptr[10];

int main(int argc, char *argv[])
{
    printf("int size = %d\n",sizeof(int));
    printf("void size = %d\n",sizeof(void));
    printf("void* size = %d\n",sizeof(void *));
    printf("void* main_arena = %p\n",main_arena);

    malloc_all();
    free_all();
}        

void malloc_all() 
{
    ptr[1] = (char*)malloc_wrapper(CHUNKSIZE);
    ptr[2] = (char*)malloc_wrapper(CHUNKSIZE);
    ptr[3] = (char*)malloc_wrapper(CHUNKSIZE);

    for (i=1 ; i<10;i++) {
        if(ptr[i]) {
            printf("ptr[%02d] = %p\n",i,ptr[i]);
        }
    }
}
void free_all()
{
    printf("call free1: ptr1 -> ptr2 -> ptr3\n");
    printf("free ptr[1]:%p\n",ptr[1]);
    free_wrapper(ptr[1]);
    printf("free ptr[2]:%p\n",ptr[2]);
    free_wrapper(ptr[2]);
    printf("free ptr[3]:%p\n",ptr[3]);
    free_wrapper(ptr[3]);
}


void dump_malloc_chunk(void* ptr)
{
    mchunk_ptr chunk, prev_chunk, next_chunk, nnext_chunk,large_chunk;
    char status;
    if(!ptr) {
        printf("[-] heap ptr == NULL\n");
        return;        
    }
    // print current chunk
    chunk = (mchunk_ptr)(ptr-2*sizeof(void*));
    next_chunk = (mchunk_ptr)((long)chunk + (chunk->size>>1<<1) );
    printf("[+] cur_chunk : [%p]\n",chunk);
    printf("[+] chunk size: [%x]\n",chunk->size);
    if( 0 == next_chunk->size>>1<<1) { // current chunk is free
        printf("[+] chunk status: free\n");
    }else {
        printf("[+] chunk status: used\n");
    }

    // print previous chunk
    if( 0 == chunk->size>>1<<1 ) { // prev_chunk is free
        prev_chunk = (mchunk_ptr)((long)chunk + (chunk->size>>1<<1) ); 
        printf("[+] prev_chunk: [%p]\n", prev_chunk);
        printf("[+] prev_chunk status: free\n");
    }else {
        printf("[+] prev_chunk status: used\n");
    }
    
    // print next chunk
    printf("MAX_LARGEBIN_SIZE=%x\n",MAX_LARGEBIN_SIZE);
    printf("next_chunk->size=%x\n",next_chunk->size>>1<<1);
    if(MAX_LARGEBIN_SIZE < (next_chunk->size>>1<<1) ) {  // next chunk is large chunk
        large_chunk = next_chunk;
        printf("[+] large_chunk: [%p]\n", large_chunk);
        printf("[+] large_chunk size: [%p]\n", (large_chunk->size>>1<<1));
    }else {
        printf("[+] next_chunk: [%p]\n", next_chunk);
    
        nnext_chunk = (mchunk_ptr)((long)next_chunk + (next_chunk->size>>1<<1));
        printf("[+] nnext_chunk: [%p]\n", nnext_chunk);
        getchar();
        if(0 == nnext_chunk->size>>1<<1 ) { // next_chunk is free
            printf("[+] next_chunk status: free\n");
        }else {
            printf("[+] next_chunk status: used\n");
        }
    }

    

    if( 0x01) {
        printf("[+] status: used\n");
    }else {
        printf("[+] status: free\n");
    }


    printf("\n");
}

void* malloc_wrapper(int size)
{
    void *ptr = NULL;
    if (size <=0) {
        printf("[-] malloc size == 0\n");
        return ptr;
    }
    ptr = malloc(size);
    if(!ptr) {
        printf("[-] malloc error\n");
        return ptr;        
    }
    dump_malloc_chunk(ptr);
    return ptr;  
}

void free_wrapper(void* ptr)
{
    if (!ptr) {
        printf("[-] free pointer == NULL\n");
        return;
    }
    free(ptr);
    dump_malloc_chunk(ptr);
}
